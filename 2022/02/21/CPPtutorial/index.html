<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>My notebook for CPP Tutorial | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="In this post, I will write down some details about my learning process of watching C++ tutorial on Youtube. You can find more details from C++ series">
<meta property="og:type" content="article">
<meta property="og:title" content="My notebook for CPP Tutorial">
<meta property="og:url" content="http://example.com/2022/02/21/CPPtutorial/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="In this post, I will write down some details about my learning process of watching C++ tutorial on Youtube. You can find more details from C++ series">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/CPPHeaderFile.png">
<meta property="og:image" content="http://example.com/img/include_error.png">
<meta property="og:image" content="http://example.com/img/visibility-in-classes.png">
<meta property="og:image" content="http://example.com/img/static_variable_1.png">
<meta property="og:image" content="http://example.com/img/static_variable_2.png">
<meta property="og:image" content="http://example.com/img/static_variable_3.png">
<meta property="og:image" content="http://example.com/img/static_variable_4.png">
<meta property="og:image" content="http://example.com/img/static_inside_class_1.png">
<meta property="og:image" content="http://example.com/img/static_inside_class_2.png">
<meta property="og:image" content="http://example.com/img/static_inside_class_3.png">
<meta property="og:image" content="http://example.com/img/Create_two_entities.png">
<meta property="og:image" content="http://example.com/img/use_parameterlist_to_avoid_recreation.png">
<meta property="og:image" content="http://example.com/img/keword_new_in_instantiation.png">
<meta property="article:published_time" content="2022-02-21T10:45:00.000Z">
<meta property="article:modified_time" content="2023-10-21T17:38:06.392Z">
<meta property="article:author" content="Joseph Wang">
<meta property="article:tag" content="-c++ -Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/CPPHeaderFile.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-CPPtutorial" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/21/CPPtutorial/" class="article-date">
  <time class="dt-published" datetime="2022-02-21T10:45:00.000Z" itemprop="datePublished">2022-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming-2023tutorial/">-Programming -2023tutorial</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      My notebook for CPP Tutorial
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p><strong>In this post, I will write down some details about my learning process of watching C++ tutorial on Youtube. You can find more details from <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=18c3MTX0PK0&t=332s">C++ series</a></strong></p>
<span id="more"></span>

<h2 id="1-Introduction-to-C"><a href="#1-Introduction-to-C" class="headerlink" title="1.Introduction to C++"></a>1.Introduction to C++</h2><h3 id="1-1-Why-we-should-learn-C-Isn’t-C-deprecated-What-else-does-C-bring-nowadays"><a href="#1-1-Why-we-should-learn-C-Isn’t-C-deprecated-What-else-does-C-bring-nowadays" class="headerlink" title="1.1 Why we should learn C++? Isn’t C++ deprecated? What else does C++ bring nowadays"></a>1.1 Why we should learn C++? Isn’t C++ deprecated? What else does C++ bring nowadays</h3><p>if you would like to write efficient, boost, and well-performing code,C++ is the ‘best’ choice.<br>the most popular reason for those who write code in C++ is the direct control on hardware.<br>other languages like C# or java, they basically run on a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_virtual_machine">virtual machine</a>, which means your code gets compiled into an intermediate language first. When you run your application on the target platform, the VM need to convert it into machine code at runtime!<br>C++ compiler itself produces machine code for target platform, so there’s absolutely no translation from an intermediate language.</p>
<h2 id="2-How-to-setup-C-on-Windows-Mac-Linux"><a href="#2-How-to-setup-C-on-Windows-Mac-Linux" class="headerlink" title="2.How to setup C++ on Windows&#x2F;Mac&#x2F;Linux"></a>2.How to setup C++ on Windows&#x2F;Mac&#x2F;Linux</h2><h2 id="3-How-C-works"><a href="#3-How-C-works" class="headerlink" title="3.How C++ works"></a>3.How C++ works</h2><h3 id="3-1-a-simple-C-program-structure"><a href="#3-1-a-simple-C-program-structure" class="headerlink" title="3.1 a simple C++ program structure"></a>3.1 a simple C++ program structure</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="comment">//anything that start with &#x27;#&#x27;character indicates a preprocessor statement</span></span><br><span class="line"><span class="comment">//preprocessing indicates that this part happens before compilation</span></span><br><span class="line"><span class="comment">// &#x27;#include &lt;iostream&gt;&#x27; take all the contents of that file and paste it into our code</span></span><br><span class="line"><span class="comment">//these files that we have included are usually called header file</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">    <span class="comment">//every program written in C++ should have the main function</span></span><br><span class="line">    <span class="comment">//main() function is the entry point to our program.</span></span><br><span class="line">    <span class="comment">//when we run our application, the computer will find and run main() function first</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">//&#x27;&lt;&lt;&#x27; is actually an overloaded operator, we can actually think of them as a function()</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-How-our-original-program-file-to-be-converted-into-executable-binary-file"><a href="#3-2-How-our-original-program-file-to-be-converted-into-executable-binary-file" class="headerlink" title="3.2 How our original program file to be converted into executable binary file?"></a>3.2 How our original program file to be converted into executable binary file?</h3><p>the compiler itself will convert our original cpp files to objection files. And the linker will help us to stitch those obj file into one executable file. Those haven’t yet gotten compiled are actually CPP file. We make those files get compiled individually and we’ll get objection files then.Those objection files indicates the result of compiling our CPP file.</p>
<h3 id="3-3-Debugging-your-code-with-technical-tools-in-microsoft-visual-studio"><a href="#3-3-Debugging-your-code-with-technical-tools-in-microsoft-visual-studio" class="headerlink" title="3.3 Debugging your code with technical tools in microsoft visual studio"></a>3.3 Debugging your code with technical tools in microsoft visual studio</h3><p>I don’t actually use microsoft visual stduio, but I’ve read something about Debugging in Visual Studio Code <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/debugging">Debugging in Visual Studio Code</a></p>
<h3 id="3-4-Declaration-vs-Definition"><a href="#3-4-Declaration-vs-Definition" class="headerlink" title="3.4 Declaration vs. Definition"></a>3.4 Declaration vs. Definition</h3><p>by using a declaration, we give a statement to our compiler that a function or a symbol does exist.<br>A definition indicates what a funtion is and this is the body for this function<br>Although a declaration is similar to a definition, what it doesn’t actually have is the actual body.</p>
<h3 id="3-5-How-does-the-linker-work"><a href="#3-5-How-does-the-linker-work" class="headerlink" title="3.5 How does the linker work?"></a>3.5 How does the linker work?</h3><p>When we build our program once our files have been compiled, the linker will actually find the definition of various symbols or functions even though they are not in the same file. Otherwise, if the linker cannot find the definition, we’ll get a link error</p>
<h3 id="3-6-There-are-additional-in-depth-videos-about-‘How-C-compiler-works’-and-‘How-C-linker-works’"><a href="#3-6-There-are-additional-in-depth-videos-about-‘How-C-compiler-works’-and-‘How-C-linker-works’" class="headerlink" title="3.6 There are additional in-depth videos about ‘How C++ compiler works’ and ‘How C++ linker works’"></a>3.6 There are additional in-depth videos about ‘How C++ compiler works’ and ‘How C++ linker works’</h3><p>As we’ve mentioned in previous part of post, before our text files eventually to be converted into executable file, there are basically two steps.</p>
<h4 id="3-6-1-How-C-compiler-work"><a href="#3-6-1-How-C-compiler-work" class="headerlink" title="3.6.1 How C++ compiler work?"></a>3.6.1 How C++ compiler work?</h4><p>What our compiler to do is to take our text files and convert them into an intermediate format called object files.</p>
<p>C++ compiler: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3tIqpEmWMLI&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=6">How C++ compiler works</a></p>
<h4 id="3-6-2-How-C-linker-work"><a href="#3-6-2-How-C-linker-work" class="headerlink" title="3.6.2 How C++ linker work?"></a>3.6.2 How C++ linker work?</h4><p>C++ linker: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=H4s55GgAg0I&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=7">How C++ linker works</a></p>
<h2 id="4-Variables-in-C"><a href="#4-Variables-in-C" class="headerlink" title="4.Variables in C++"></a>4.Variables in C++</h2><p>When writing programs in C++, we are manipulating data.(change, read, write, etc.)<br>we store our data in something called variable.<br>variable allows us to name a piece of data stored in memory, so we can keep using it</p>
<h3 id="4-1-in-C-we’re-given-a-bunch-of-primitive-data-types"><a href="#4-1-in-C-we’re-given-a-bunch-of-primitive-data-types" class="headerlink" title="4.1 in C++, we’re given a bunch of primitive data types"></a>4.1 in C++, we’re given a bunch of primitive data types</h3><p>These primitive datatype essentially form the building block of any kind of data we store in our program<br>The really only distinction between the different variable types you have in C++ is the size<br>That is How many memory does this variable occupy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> variable = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//an integer-type variable occupies a 4-byte(equals to 32bits) space in the memory</span></span><br><span class="line">    <span class="comment">//an unsigned-integer-type variable always represents a positive number</span></span><br><span class="line">    std::cout &lt;&lt; variable &lt;&lt; std::endl;</span><br><span class="line">    variable = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//How do we know the size of data type?</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we have short(2-byte datatype), char(1-byte datatype), long(4-byte datatype), long long(8-byte datatype),<br>float(4-byte), double(8-byte), bool(1-byte, cus data retrieval), etc.</p>
<h2 id="5-functions-in-C"><a href="#5-functions-in-C" class="headerlink" title="5.functions in C++"></a>5.functions in C++</h2><h3 id="every-program-is-built-from-a-collection-of-functions"><a href="#every-program-is-built-from-a-collection-of-functions" class="headerlink" title="every program is built from a collection of functions."></a>every program is built from a collection of functions.</h3><h3 id="5-1-define-it-and-call-it"><a href="#5-1-define-it-and-call-it" class="headerlink" title="5.1 define it and call it"></a>5.1 define it and call it</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiplyAandB</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//define the function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//function body</span></span><br><span class="line">    <span class="keyword">return</span> a * b; <span class="comment">//asterisk &quot;*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiplyAandB</span>(a, b); <span class="comment">//call the function</span></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Do-we-need-to-define-and-call-more-functions"><a href="#5-2-Do-we-need-to-define-and-call-more-functions" class="headerlink" title="5.2 Do we need to define and call more functions?"></a>5.2 Do we need to define and call more functions?</h3><p>it seems that we can make our program more brevity and readable by collecting those code into bodies.<br>So do we need to define and call more functions?<br>When we call our functions too often, however, it takes time(make your programs run slower)</p>
<p><strong>every time we call a function,the compiler itself generates a call instruction:</strong><br>In a running program:<br><strong>suppose we don’t even use an inline function</strong><br>in order for us to call a function, we need to create the entire stack frame for the function, which means:<br>we should push funcitons, some parameters, a return address onto the stack.<br>What we do is actually jump to a different part of binary so that we can start executing from our function.<br>We then need to push our return value onto the stack and get back to where we originally were.<br>…<br>just jumping around the memory in order to execute our functions and instructions:<br>All of that takes time, so it actually slows down our program.</p>
<h3 id="5-3-main-is-exmept-from-this-kind-of-‘must-return-value’"><a href="#5-3-main-is-exmept-from-this-kind-of-‘must-return-value’" class="headerlink" title="5.3 main() is exmept from this kind of ‘must return value’"></a>5.3 main() is exmept from this kind of ‘must return value’</h3><p>if you don’t specify your main() to return a certain value, it will atomatically assume that you’re returning zero</p>
<p>Do functions with the return type need to return values? - Absolutely yes! otherwise your compile will send you an error.</p>
<h3 id="5-4-declaration-and-definition-of-a-function"><a href="#5-4-declaration-and-definition-of-a-function" class="headerlink" title="5.4 declaration and definition of a function"></a>5.4 declaration and definition of a function</h3><p>we generally break up a function into declaration and definition when start building a project.<br>We deploy our declarations in the header files and we write our definitions in CPP file.</p>
<h2 id="6-C-Header-Files"><a href="#6-C-Header-Files" class="headerlink" title="6.C++ Header Files"></a>6.C++ Header Files</h2><h3 id="6-1-header-file-structure-in-a-C-program"><a href="#6-1-header-file-structure-in-a-C-program" class="headerlink" title="6.1 header file structure in a C++ program"></a>6.1 header file structure in a C++ program</h3><p>As I’ve mentioned in the previous part of my posts. We need our declarations to tell our compile: Hey, xxx function does exists! And a header file is actually a collection of declarations.</p>
<p><img src="/../img/CPPHeaderFile.png" alt="a header file example"></p>
<p>And you may find something useful in <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3202136/using-g-to-compile-multiple-cpp-and-h-files">Using g++ to compile mutiple .cpp and .h files</a> and <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6532400/linking-files-in-g">linking files in g++</a>, if you have forgotten how to compile more than one .cpp files by using commands in terminal.</p>
<h3 id="6-2-What-is-‘pragma-once’"><a href="#6-2-What-is-‘pragma-once’" class="headerlink" title="6.2 What is ‘pragma once’"></a>6.2 What is ‘pragma once’</h3><p>we have mentioned that something starts with ‘#’ indicates a preprocessor command or a preprocessor directive.<br>It means this is going to be evaluated by C++ preprocessor before it’s going to get compiled.<br>It actually means: <strong>only include once</strong><br>That is, to <strong>prevent us from including a single header file mutiple times into a single compilation(or a translation unit)</strong><br><strong>but it doesn’t mean it prevents us from including our header file into multiple place in our program</strong></p>
<p>see below what will happen if we include our “Log.h” more than once.</p>
<p><img src="/../img/include_error.png" alt="receive an error about pragma once"></p>
<p>find more details in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pragma_once#Advantages">prama once</a></p>
<p>we can also use ‘#ifndef _Log_H’, ‘#define _Log_H’, ‘#endif’ to tell our compiler that the ‘Log.h’ can be only included once in a single compilation.</p>
<h3 id="6-3-‘-include-’-and-‘-include-“”‘-represent-different-type-of-lib-path"><a href="#6-3-‘-include-’-and-‘-include-“”‘-represent-different-type-of-lib-path" class="headerlink" title="6.3 ‘#include &lt;&gt;’ and ‘#include “”‘ represent different type of lib path."></a>6.3 ‘#include &lt;&gt;’ and ‘#include “”‘ represent different type of lib path.</h3><p>We can use ambiguous search method by the given ‘include’ path.</p>
<h2 id="7-Pointers-in-C"><a href="#7-Pointers-in-C" class="headerlink" title="7. Pointers in C++"></a>7. Pointers in C++</h2><h3 id="7-1-You-need-to-get-everything-from-memory"><a href="#7-1-You-need-to-get-everything-from-memory" class="headerlink" title="7.1 You need to get everything from memory"></a>7.1 You need to get everything from memory</h3><p>As I’ve mentioned in the previous part of my post, programmers tend to write code in C++ due to its direct control on the memory.</p>
<h3 id="7-2-pointer-is-the-most-extremely-helpful-tool-for-us-to-manage-and-manipulate-our-memory"><a href="#7-2-pointer-is-the-most-extremely-helpful-tool-for-us-to-manage-and-manipulate-our-memory" class="headerlink" title="7.2 pointer is the most extremely helpful tool for us to manage and manipulate our memory."></a>7.2 pointer is the most extremely helpful tool for us to manage and manipulate our memory.</h3><h3 id="7-3-What-is-a-pointer"><a href="#7-3-What-is-a-pointer" class="headerlink" title="7.3 What is a pointer?"></a>7.3 What is a pointer?</h3><p>Actually, from my perspective, pointer is an integer representing a certain address for a certain piece of memory.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = &amp;var;</span><br><span class="line">    <span class="comment">//note that types do not matter!</span></span><br><span class="line">    <span class="type">int</span>* ptr1 = &amp;var;</span><br><span class="line">    <span class="type">double</span>* ptr2 = (<span class="type">double</span>*) &amp;var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use asterisk to read from or write to</span></span><br><span class="line">    *ptr = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">//error! we haven&#x27;t yet told compiler the type of &#x27;10&#x27;, &#x27;10&#x27; can mean anything(short, int, long long, etc.)</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//it&#x27;ll create 8 byte memory for us</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">//it&#x27;ll fill a block of memory with value that we specify.</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>** ptrt = &amp;buffer;</span><br><span class="line">    <span class="comment">//it indicates a pointer points to a pointer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-4-void-pointer"><a href="#7-4-void-pointer" class="headerlink" title="7.4 void pointer"></a>7.4 void pointer</h3><p>A void pointer is a pointer that has no associated data type with it. A void pointer can hold an address of any type and can be typecasted to any type.<br>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* ptr = &amp;a; <span class="comment">//a void pointer can hold an address of any type </span></span><br><span class="line">    ptr = &amp;c;   <span class="comment">//A void pointer can be typecasted to any type</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But a void pointer cannot be directly dereferenced.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a= <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = &amp;a;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">//Compiler Error: &#x27;void*&#x27; is not a pointer-to-object type</span></span><br><span class="line">    std::cout &lt;&lt; *((<span class="type">int</span>*)ptr) &lt;&lt; std::endl; <span class="comment">//OK,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="we’re-not-expected-to-specify-our-pointer-without-an-address"><a href="#we’re-not-expected-to-specify-our-pointer-without-an-address" class="headerlink" title="we’re not expected to specify our pointer without an address"></a>we’re not expected to specify our pointer without an address</h3><p>Let’s see something enlightening below</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in main function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">    *ptr = <span class="number">4</span>;   <span class="comment">//error. If we want our pointer points to a value, our pointer need to hold an address.</span></span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;v;</span><br><span class="line">    *ptr = <span class="number">4</span>; <span class="comment">//OK </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-References-in-C"><a href="#8-References-in-C" class="headerlink" title="8.   References in C++"></a>8.   References in C++</h2><h3 id="8-1-Reference-is-a-way-for-us-to-reference-already-existing-variables"><a href="#8-1-Reference-is-a-way-for-us-to-reference-already-existing-variables" class="headerlink" title="8.1 Reference is a way for us to reference already existing variables."></a>8.1 Reference is a way for us to reference already existing variables.</h3><p>Some enlightening examples below can give us more mature outlook on properties of reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> &amp; ref = a; </span><br><span class="line">    <span class="comment">//using ampersand &#x27;&amp;&#x27; with datatype to reference an already existing variable</span></span><br><span class="line">    <span class="comment">//we&#x27;ve essentially created an alias</span></span><br><span class="line">    <span class="comment">//an alias occurs when different variables point directly or indirectly to a single area of storage</span></span><br><span class="line">    ref = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a); <span class="comment">//a is equal to 2 now</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Something maybe more complicated</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> * value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*value++; error! we should dereference first and then increment</span></span><br><span class="line">    (*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_ref_version</span><span class="params">(<span class="type">int</span> &amp; value)</span> </span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> * a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">increment</span>(&amp;a);</span><br><span class="line">    <span class="comment">//we can push the adress of &#x27;a&#x27; into the stack instead of a value</span></span><br><span class="line">    <span class="built_in">LOG</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>(a);</span><br><span class="line">    <span class="comment">//the two increment function basically do the same thing.</span></span><br><span class="line">    <span class="comment">//So there&#x27;s nothing you can do with a reference that you cannot do with a pointer</span></span><br><span class="line">    <span class="built_in">LOG</span>(a); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>wo if I use an existing reference to tickle another existing variable,like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> &amp; ref = a;</span><br><span class="line">    ref = b; <span class="comment">//a = 5, b = 5</span></span><br><span class="line">    <span class="comment">//it doesn&#x27;t end up establishing a brand new connection between ref and b</span></span><br><span class="line">    <span class="comment">//We may expect our reference &#x27;ref&#x27; to reference variable &#x27;b&#x27;</span></span><br><span class="line">    <span class="comment">//Actually, the variable &#x27;a&#x27; ended up being assigned by a new value given by b(b equals to 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//things can be different if we use a pointer, see:</span></span><br><span class="line">    <span class="type">int</span> * ptr = &amp;a;</span><br><span class="line">    ptr = &amp;b; <span class="comment">//our pointer ptr now points to a brand new piece of memory, where b is stored.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Classes-in-C"><a href="#9-Classes-in-C" class="headerlink" title="9.   Classes in C++"></a>9.   Classes in C++</h2><h3 id="9-1-Object-oriented-Programming-OOP-One-of-the-most-popular-coding-style"><a href="#9-1-Object-oriented-Programming-OOP-One-of-the-most-popular-coding-style" class="headerlink" title="9.1 Object-oriented Programming(OOP) - One of the most popular coding style"></a>9.1 Object-oriented Programming(OOP) - One of the most popular coding style</h3><p>find more details in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object-oriented programming</a></p>
<h3 id="9-2-What-are-classes-in-C"><a href="#9-2-What-are-classes-in-C" class="headerlink" title="9.2 What are classes in C++?"></a>9.2 What are classes in C++?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">//horizontal axis</span></span><br><span class="line">    <span class="type">int</span> y;  <span class="comment">//vertical axis</span></span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;; <span class="comment">//note that our definition of class must end up with a semicolon.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player; </span><br><span class="line">    <span class="comment">//variables that are made from class types are called objects</span></span><br><span class="line">    <span class="comment">//and a new object variable is called an instance</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>seems that we can initialize our instance ‘player’ like this</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    player.y = <span class="number">2</span>;</span><br><span class="line">    player.speed = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>see what will happen.</p>
<h3 id="9-2-visibility-in-classes"><a href="#9-2-visibility-in-classes" class="headerlink" title="9.2 visibility in classes"></a>9.2 visibility in classes</h3><p><img src="/../img/visibility-in-classes.png" alt="visibility in classes"></p>
<p>What our compiler tell us indicates that the ‘player’ <strong>cannot</strong> access <strong>private member</strong> declared in class <strong>‘Player’</strong><br>This is called visibility<br>Fortunately, C++ allows us to specify to what extent visible the stuff in that class is when we create a new class.<br>By default, the class make everything private which means only functions(also called procedures or methods) in it can access those variables.</p>
<p>So if we want to access them from the main function:<br>we need to do something like below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//make it public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>to make it public, we’re allowed to access these variables outside of this class anywhere in our code</p>
<h3 id="9-3-functions-in-our-class"><a href="#9-3-functions-in-our-class" class="headerlink" title="9.3 functions in our class"></a>9.3 functions in our class</h3><p>functions in our class are called methods. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span> </span>&#123;</span><br><span class="line">        player.x += xa * player.speed;</span><br><span class="line">        player.y += ya * player.speed; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-Classes-allow-us-to-group-variables-together-into-a-type"><a href="#9-3-Classes-allow-us-to-group-variables-together-into-a-type" class="headerlink" title="9.3 Classes allow us to group variables together into a type"></a>9.3 Classes allow us to group variables together into a type</h3><h3 id="9-4-Classes-VS-Structs-in-C"><a href="#9-4-Classes-VS-Structs-in-C" class="headerlink" title="9.4 Classes VS. Structs in C++"></a>9.4 Classes VS. Structs in C++</h3><p>There is one small difference to do with visibility.<br>The default with respect to visibility in classes is private,whereas in struct is public.</p>
<h3 id="9-5-print-in-console-write-log-function"><a href="#9-5-print-in-console-write-log-function" class="headerlink" title="9.5 print in console (write log function)"></a>9.5 print in console (write log function)</h3><p>we can use log functions for errors, warnings, and tracing messages</p>
<h3 id="9-6-what-does-STATIC-mean-in-C"><a href="#9-6-what-does-STATIC-mean-in-C" class="headerlink" title="9.6 what does STATIC mean in C++"></a>9.6 what does STATIC mean in C++</h3><p>have two meanings (context) inside class or outside class</p>
<h4 id="9-6-1-static-variables-outside-the-class"><a href="#9-6-1-static-variables-outside-the-class" class="headerlink" title="9.6.1 static variables outside the class:"></a>9.6.1 static variables outside the class:</h4><p>only invisable to the translation unit that you’ve defined it in.</p>
<p>find more details about ‘translation unit’ in Wikipedia<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Translation_unit_(programming)">translation unit</a></p>
<p>There’s also something helpful about ‘how to understand source file in C++’<br>it’s internal linkage. see something enlightening below.</p>
<p><img src="/../img/static_variable_1.png" alt="one static variable"></p>
<p>we won’t receive an error from our compiler.<br>What if we specify two variable ‘s_variable’ in separate .cpp file.</p>
<p><img src="/../img/static_variable_2.png" alt="link error: &#39;s_variable&#39; redefined"></p>
<p>we received link error from our compliler, saying that ‘s_variable’ has been redefined.<br>As we’ve mentioned previously, we can only define a variable with a certain name once, except for using keyword ‘static’</p>
<p>something more enlightening below: </p>
<p><img src="/../img/static_variable_3.png" alt="keyword extern"><br>by using keyword ‘extern’, we’ll find the initialization of ‘s_variable’ in an external translation unit</p>
<p><img src="/../img/static_variable_4.png" alt="extern s_variable in main.cpp,whereas static s_variable in static.cpp"></p>
<p>we cannot find our ‘s_variable’ anywhere because the defined variable ‘s_variable’ in static.cpp is a private variable.</p>
<p>try and mark your functions and your variables static unless you actually need them to be linked across translation units.</p>
<h4 id="9-6-2-static-variables-inside-the-classes-structs"><a href="#9-6-2-static-variables-inside-the-classes-structs" class="headerlink" title="9.6.2 static variables inside the classes(structs)"></a>9.6.2 static variables inside the classes(structs)</h4><p>if we use keyword ‘static’ to mark a certain variable, it means that there’s only one instance of that variable across all instances of the class.</p>
<p>In that case, if one of our instance of that class changes our ‘static’ variable, it is going to reflect that change across all the instances of the class</p>
<p>let’s see something enlightening below:</p>
<p><img src="/../img/static_inside_class_1.png" alt="a class called &#39;Entity&#39; and two instances &#39;e&#39; and &#39;e1&#39;"></p>
<p>what if we mark x and y as static members.<br>note that if we do not declare our static-member variables somewhere in our .cpp file, we’ll receive link error from our compiler like below:</p>
<p><img src="/../img/static_inside_class_2.png" alt="link error:cannot find our static-member variables"></p>
<p>we can easily fix it by declaring x,y in advance.</p>
<p><img src="/../img/static_inside_class_3.png" alt="declare your static-member variable in advance"></p>
<p>we find that although we’ve specified our (x,y) pairs with two different value pairs separately, we only have one instance across this two instances of ‘Entity’ class.<br>That means: our two instances ‘e’ and ‘e1’ share the same memory about static-member variables ‘x’ and ‘y’</p>
<p>we can also write our code in this way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in function main:</span></span><br><span class="line">Entity::x = <span class="number">5</span>;</span><br><span class="line">Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static-member methods work in a similar way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we need to mark our x,y as static members because our static-member function cannot access to non-static members.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    Entity e, e1;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-Constructors-in-C"><a href="#10-Constructors-in-C" class="headerlink" title="10.Constructors in C++"></a>10.Constructors in C++</h2><h3 id="10-1-some-fundamental-properties"><a href="#10-1-some-fundamental-properties" class="headerlink" title="10.1 some fundamental properties"></a>10.1 some fundamental properties</h3><p>we generally use constructors to initialize our instance and do any setups you need whenever creating your instance<br>a constructor itself does not have any return type. Its name is the same as the name of the class.<br>If we don’t definite constructors ourselves, our system will automatically generate default constructors. the structure of default constructor is something like this below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        <span class="comment">//equals to default constructors.</span></span><br><span class="line">        <span class="comment">//automatically generated by our system</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>we can define as many constructors in a class as we want, but we need to obey ‘overload’ rules.<br>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class Entity, we overload our constructors</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        x = x;</span><br><span class="line">        y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-2-ways-to-remove-constructors"><a href="#10-2-ways-to-remove-constructors" class="headerlink" title="10.2 ways to remove constructors"></a>10.2 ways to remove constructors</h3><h3 id="10-2-1-use-‘private’-to-implement-visibility-restriction"><a href="#10-2-1-use-‘private’-to-implement-visibility-restriction" class="headerlink" title="10.2.1 use ‘private’ to implement visibility restriction"></a>10.2.1 use ‘private’ to implement visibility restriction</h3><p>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class Log</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>() &#123;&#125; <span class="comment">//As we&#x27;ve mentioned above, this equals to default constructors</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//in main()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log::<span class="built_in">Write</span>();</span><br><span class="line">    Log l; <span class="comment">//actually we&#x27;ll receive an error here, cus our compiler cannot find  the constructor anywhere</span></span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-tell-our-system-directly-that-we-do-not-need-a-default-constructor"><a href="#10-2-2-tell-our-system-directly-that-we-do-not-need-a-default-constructor" class="headerlink" title="10.2.2 tell our system directly that we do not need a default constructor"></a>10.2.2 tell our system directly that we do not need a default constructor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class Log</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">delete</span>;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-Destructors-in-C"><a href="#11-Destructors-in-C" class="headerlink" title="11. Destructors in C++"></a>11. Destructors in C++</h2><h3 id="11-1-basic-structure-of-destructor"><a href="#11-1-basic-structure-of-destructor" class="headerlink" title="11.1 basic structure of destructor"></a>11.1 basic structure of destructor</h3><p>In OOP, a destructor is a method which is invoked mechanically just before the memory of the object is released.<br>The destructor has the same name as the class, but with a tilde (~) before it.<br>Additionally, destructors have neither parameters nor return type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        <span class="comment">//equals to default constructor</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">        <span class="comment">//our structure of the destructor begins with a &#x27;tilde&#x27; </span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destructor called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//note that if you don&#x27;t define a destructor, the compiler provides a default one</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-2-Destructor-get-called-WHEN"><a href="#11-2-Destructor-get-called-WHEN" class="headerlink" title="11.2 Destructor get called WHEN"></a>11.2 Destructor get called WHEN</h3><p>Generally, as stated above, a destructor for an object is called whenever the object’s lifetime ends.<br><strong>Destructors are called when one of the following events occurs:</strong></p>
<ul>
<li><p>A local (automatic) object with block scope goes out of scope.</p>
</li>
<li><p>An object allocated using the <strong>new</strong> operator is explicitly deallocated using <strong>delete.</strong></p>
</li>
<li><p>The lifetime of a temporary object ends.</p>
</li>
<li><p>A program ends and global or static objects exist.</p>
</li>
<li><p>The destructor is explicitly called using the destructor function’s fully qualified name.</p>
</li>
</ul>
<p>Sometimes we don’t want our destructor get called.<br>if you’ve allocated any memory on the heap manually and you need to manually clean it up</p>
<h3 id="11-3-some-interesting-properties-I’ll-dive-into-this-part-in-the-future"><a href="#11-3-some-interesting-properties-I’ll-dive-into-this-part-in-the-future" class="headerlink" title="11.3 some interesting properties.(I’ll dive into this part in the future)"></a>11.3 some interesting properties.(I’ll dive into this part in the future)</h3><p>Destructors can freely call class member functions and access class member data.<br>There’re two restrictions on the use of destructors:</p>
<ul>
<li>You cannot take its address.</li>
<li>Derived classes don’t inherit the destructors of their base class.</li>
</ul>
<h3 id="11-4-order-of-destruction-I’ll-dive-into-this-part-in-the-future"><a href="#11-4-order-of-destruction-I’ll-dive-into-this-part-in-the-future" class="headerlink" title="11.4 order of destruction.(I’ll dive into this part in the future)"></a>11.4 order of destruction.(I’ll dive into this part in the future)</h3><h3 id="11-5-cases-when-we-don’t-our-destructors-get-called-I’ll-dive-into-this-part-in-the-future"><a href="#11-5-cases-when-we-don’t-our-destructors-get-called-I’ll-dive-into-this-part-in-the-future" class="headerlink" title="11.5 cases when we don’t our destructors get called. (I’ll dive into this part in the future)"></a>11.5 cases when we don’t our destructors get called. (I’ll dive into this part in the future)</h3><p>find more details in <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/cpp/destructors-cpp?view=msvc-170">Destructors</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Destructor_(computer_programming)">Destructor (computer programming)</a> and <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/dtors">Destructors,C++FAQ</a></p>
<h2 id="12-Inheritance-in-C"><a href="#12-Inheritance-in-C" class="headerlink" title="12. Inheritance in C++"></a>12. Inheritance in C++</h2><h3 id="12-1-Defs-Properties"><a href="#12-1-Defs-Properties" class="headerlink" title="12.1 Defs &amp; Properties"></a>12.1 Defs &amp; Properties</h3><p>The capability of a class to derive properties and characteristics from another class is called Inheritance.<br>in this process, a new class is created from an existing class.<br>The brand new class is called <strong>derived class</strong> or <strong>child class</strong><br>The existing class is called <strong>parent class</strong> or <strong>base class</strong></p>
<p>when we say derived class <strong>inherits</strong> the base class, it means:</p>
<ol>
<li>inherits all the properties of the base class(except private members)</li>
<li>without changing the properties of base class and may bring about new properities and features to its own.</li>
</ol>
<h3 id="12-2-Why-we-use-inheritance-in-c"><a href="#12-2-Why-we-use-inheritance-in-c" class="headerlink" title="12.2 Why we use inheritance in c++?"></a>12.2 Why we use inheritance in c++?</h3><p>can avoid code duplications<br>code duplications: write or run the exact code for many times</p>
<p>find more details about duplicate code and why not deplicate code inp<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Duplicate_code">duplicate code</a> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa , <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">        x+=xa;</span><br><span class="line">        y+=ya;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*class Player &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    float x, y;</span></span><br><span class="line"><span class="comment">    const char* name;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void Move(float xa, float ya) &#123;</span></span><br><span class="line"><span class="comment">        x += xa;</span></span><br><span class="line"><span class="comment">        y += ya;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void printName() &#123;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//we can find that the class &#x27;Player&#x27; has the similar members to some extent</span></span><br><span class="line"><span class="comment">//and that&#x27;ll cause code duplication</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//we can use inheritance </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    p1.<span class="built_in">printNmae</span>();</span><br><span class="line">    p1.<span class="built_in">Move</span>(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">//OK</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-Virtual-Function-in-C"><a href="#13-Virtual-Function-in-C" class="headerlink" title="13. Virtual Function in C++"></a>13. Virtual Function in C++</h2><h3 id="13-1-exs-and-explaination"><a href="#13-1-exs-and-explaination" class="headerlink" title="13.1 exs and explaination?"></a>13.1 exs and explaination?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp; name): <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in function main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Joseph&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//Entity</span></span><br><span class="line">    <span class="comment">//Joseph</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>just see something enlightening below</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if we specify a Entity-class-type pointer to point our &#x27;p&#x27; instance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Joseph&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Entity* e1 = p;</span><br><span class="line">    std::cout &lt;&lt; e1-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//Entity</span></span><br><span class="line">    <span class="comment">//Joseph</span></span><br><span class="line">    <span class="comment">//Entity</span></span><br><span class="line">    <span class="comment">//but actually our e1 should represent as a Player-class instance.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Then that’s what <strong>‘Virtual function’</strong> works for.</p>
<p>if you want to override a function that has already exited in parent class, you need to mark the base function in the base class as virtual.</p>
<p>Whenever a class defines a virtual function(or method), most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a></p>
<p>so in class Entity, let’s add the keyword <strong>‘virtual’</strong> to the <strong>‘getName’</strong> method.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//in function main</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//we can get what we want</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    Entity* e1 = p;</span><br><span class="line">    std::cout &lt;&lt; e1-&gt;<span class="built_in">getName</span>(); &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: Joseph</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-override-in-C-11"><a href="#13-2-override-in-C-11" class="headerlink" title="13.2 override in C++11"></a>13.2 override in C++11</h3><p>add the keyword <strong>‘override’</strong> to the overriden method in the subclass so that we can make our code more readable. But dont forget the keyword <strong>‘virtual’</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> :<span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp; name): <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>every time we call for method like ‘getName()’ in the case, our system will search for the pointers in the <strong>‘virtual method table’</strong> and fetch the exact method for us and this will lead to extra penalty.</p>
<h2 id="14-interfaces-in-C"><a href="#14-interfaces-in-C" class="headerlink" title="14. interfaces in C++"></a>14. interfaces in C++</h2><p>pure virtual function - abstract method or interface </p>
<p>a pure virtual function allows us to define a function in base class that does not have an implementation and then for subclasses to actually implement that function.</p>
<p>in C++ programming, it’s quite common for us to create a class with unimplemented method and force our subclass to implement the methods.<br>And our base class with unimplemented methods actually cannot be intantiate.</p>
<p><strong>In C++, the creation of a new instance is called instantiation</strong><br>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entity and Player class in the last part</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//getName must be implemented in the subclass</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp; name):<span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> m_Name;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Entity* e = new Entity(); error. we cannot instantiate Entity class</span></span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Joseph&quot;</span>) <span class="comment">//OK</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>In that case, you can only instantiate the class if it has all its pure virtual functions implemented.</p>
<h2 id="15-visibility-in-C"><a href="#15-visibility-in-C" class="headerlink" title="15. visibility in C++"></a>15. visibility in C++</h2><h3 id="15-1-keyword-‘private’"><a href="#15-1-keyword-‘private’" class="headerlink" title="15.1 keyword ‘private’"></a>15.1 keyword ‘private’</h3><p>With the keyword <strong>‘private’</strong>, it enables us to visit the relevant members and methods within the class scope. We cannot see it, call it or use it anywhere else.</p>
<p>see something enlightening below</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        x = <span class="number">0</span>;  <span class="comment">//OK, we can access to our private member within the class scope </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span>: Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>() &#123;</span><br><span class="line">        x=<span class="number">2</span>; <span class="comment">//error, we cannot access to a private member in subclass</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">0</span>;    <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>only in that class or friend class can actually access those private members</strong></p>
<h3 id="15-2-keyword-protected"><a href="#15-2-keyword-protected" class="headerlink" title="15.2 keyword protected"></a>15.2 keyword protected</h3><p>A protected nonstatic base class member can be accessed by members and friends of any classes derived from that base class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">//OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>: <span class="keyword">public</span>: Entity&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>() &#123;</span><br><span class="line">        x = <span class="number">2</span>;  <span class="comment">//OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x=<span class="number">0</span>;  <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-3-Why-would-we-use-visibility-in-C"><a href="#15-3-Why-would-we-use-visibility-in-C" class="headerlink" title="15.3 Why would we use visibility in C++"></a>15.3 Why would we use visibility in C++</h3><p>I don’t know.</p>
<h2 id="16-split-in-C-several-methods-to-split-a-string-in-C"><a href="#16-split-in-C-several-methods-to-split-a-string-in-C" class="headerlink" title="16. split in C++ - several methods to split a string in C++"></a>16. split in C++ - several methods to split a string in C++</h2><p>spliting in C++ means splitting a string object into several pieces with some restrictions(usually, with respect to a delimiter)</p>
<ol>
<li><p>Using temporary string in C++<br> see something enlightening below:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="type">char</span> arr[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//use the getline function for input</span></span><br><span class="line">   std::cin.<span class="built_in">getline</span>(arr, <span class="number">100</span>);</span><br><span class="line">   <span class="type">char</span> = separator = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   std::vector&lt;std::vector&lt;string&gt;&gt; res;</span><br><span class="line">   </span><br><span class="line">   std::string s;</span><br><span class="line">   <span class="keyword">while</span> (arr[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr[i] == separator) &#123;</span><br><span class="line">           res.<span class="built_in">push_back</span>(s);</span><br><span class="line">           s.<span class="built_in">clear</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//append the char to the temp string</span></span><br><span class="line">           s += arr[i];</span><br><span class="line">       &#125;</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> s : res) &#123;</span><br><span class="line">       std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//input something like:</span></span><br><span class="line"><span class="comment">//&quot;one two three four five six seven eight nine ten&quot;</span></span><br><span class="line"><span class="comment">//you&#x27;ll get:</span></span><br><span class="line"><span class="comment">//one</span></span><br><span class="line"><span class="comment">//two</span></span><br><span class="line"><span class="comment">//three</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//ten</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Using string stream and getline() in C++<br> I use this method a lot when doing some practice on <a target="_blank" rel="noopener" href="https://leetcode.com/">leetcode</a><br> generally, we will instantiate a stringstream object, it’s just something like a iostream buffer for string-type variables.<br> Thanks to the operator overloading with respect to ‘&gt;&gt;’ and ‘&lt;&lt;’, we can push a string object into the stream or just extract a string object from the stream.</p>
</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Syntax of stringstream object </span></span><br><span class="line"><span class="function">stringstream <span class="title">obj_name</span><span class="params">(string string_name)</span></span>;</span><br><span class="line"><span class="comment">// find more detailed information [here](https://cplusplus.com/reference/sstream/stringstream/)</span></span><br></pre></td></tr></table></figure>
<p> see something enlightening below:<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//we&#x27;d like to implement split function by using stringstream.</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> std::string &amp; s, <span class="type">char</span> delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//outputTokens</span></span><br><span class="line">    std::vector&lt;std::string&gt; res; <span class="comment">//will store each token here</span></span><br><span class="line"></span><br><span class="line">    std::string token;</span><br><span class="line">    <span class="comment">//pass actual string to stringstream</span></span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, token, delimiter)) &#123;</span><br><span class="line">        <span class="comment">//keep appending token unless getline returning NULL</span></span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;Fuck Glasgow rainy days! I want to go back home&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; res = <span class="built_in">split</span>(s, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : res) &#123;</span><br><span class="line">        std::cout &lt;&lt; it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find something helpful with respect to &#x27;getline&#x27; [here](https://cplusplus.com/reference/string/string/getline/)</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//output:</span></span><br><span class="line"> <span class="comment">//  Fuck</span></span><br><span class="line"> <span class="comment">// Glasgow</span></span><br><span class="line"> <span class="comment">// rainy</span></span><br><span class="line"> <span class="comment">// days!</span></span><br><span class="line"> <span class="comment">// I</span></span><br><span class="line"> <span class="comment">// want</span></span><br><span class="line"> <span class="comment">// to</span></span><br><span class="line"> <span class="comment">// go</span></span><br><span class="line"> <span class="comment">// back</span></span><br><span class="line"> <span class="comment">// home</span></span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><p>Using strtok() function<br> The strtok() modifies the original string on each call by inserting the <strong>NULL</strong> character(‘\0’) at the delimiter position.<br> Syntax:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* ptr = <span class="built_in">strtok</span>(<span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* delimiter);</span><br></pre></td></tr></table></figure>
<p> On a first call, the function expects a C string as argument for str, whose first character is used as the starting location to scan for tokens. In subsequent calls, the function expects a null pointer and uses the position right after the end of the last token as the new starting location for scanning.<br> find more detailed information <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/cstring/strtok/">here</a><br> see something enlightening below:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot; - Fuck Glasgow rainy day! I&#x27;d like to go back home!&quot;</span></span><br><span class="line">   <span class="type">char</span>* token = <span class="built_in">stroke</span>(str, <span class="string">&quot; -,!&quot;</span>); <span class="comment">//separated by any of the characters that are part of delimiters.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="comment">//printf(&quot;%s\n&quot;, token);</span></span><br><span class="line">       token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; -,!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//your output:</span></span><br><span class="line">   <span class="comment">//Fuck</span></span><br><span class="line">   <span class="comment">//Glasgow</span></span><br><span class="line">   <span class="comment">//rainy</span></span><br><span class="line">   <span class="comment">//day</span></span><br><span class="line">   <span class="comment">//I&#x27;d</span></span><br><span class="line">   <span class="comment">//like</span></span><br><span class="line">   <span class="comment">//to</span></span><br><span class="line">   <span class="comment">//go</span></span><br><span class="line">   <span class="comment">//back</span></span><br><span class="line">   <span class="comment">//home</span></span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>find(), substr(), and erase()</p>
</li>
</ol>
<h2 id="17-const-in-C"><a href="#17-const-in-C" class="headerlink" title="17. const in C++"></a>17. const in C++</h2><h3 id="17-1-‘const-int-a’-vs-‘int-const-a’"><a href="#17-1-‘const-int-a’-vs-‘int-const-a’" class="headerlink" title="17.1 ‘const int * a’ vs. ‘int * const a’"></a>17.1 ‘const int * a’ vs. ‘int * const a’</h3><ol>
<li><p>‘const int * a’ means that we initialize a pointer that points to a integer value, and we cannot fix the value.<br>And <strong>‘int const * a’</strong> has the same function as <strong>‘const int * a’</strong></p>
</li>
<li><p>‘int * const a’ means that we initialize a const pointer that always points to one piece of memory in its lifetime.<br>But we can fix the value that it references to.</p>
</li>
</ol>
<h3 id="17-2-const-in-classes-and-methods"><a href="#17-2-const-in-classes-and-methods" class="headerlink" title="17.2 const in classes and methods"></a>17.2 const in classes and methods</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X, m_Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//m_X = 2; Error, we cannot modify any of these class member variables </span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="comment">//method overloading</span></span><br><span class="line">        m_X = <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Entity &amp; e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-mutable-in-C"><a href="#18-mutable-in-C" class="headerlink" title="18. mutable in C++"></a>18. mutable in C++</h2><p>Sometimes there’s requirement to modify one or more data members of class through const function even though you dont want the function to update other members of class. This can be easily performed by using keyword <strong>‘mutable’</strong></p>
<p>Imagin you have ordered some dish in a resturant, but you suddenly want a change to new order. To make it more flexible, it’s wise for restaurant to allow their customers to change their order within the limited time.</p>
<p>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">mutable</span> std::string placeorder; </span><br><span class="line">    <span class="type">int</span> tableno; </span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> bill;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="built_in">Customer</span>(std::string s,std::string m, <span class="type">int</span> a, <span class="type">int</span> p) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">        placeorder = m;</span><br><span class="line">        tableno = a;</span><br><span class="line">        bill = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//to change the order</span></span><br><span class="line">    <span class="comment">//note that by using const member method,we make a promise to compiler that</span></span><br><span class="line">    <span class="comment">//we won&#x27;t make state of Object&#x27;s field within this method.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changePlaceOrder</span><span class="params">(string p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        placeorder = p; <span class="comment">//by using keyword &#x27;mutable&#x27;, we can make change even in const member method.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//change the bill accordingly</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeBill</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span> </span>&#123; bill = s; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...to display</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mutable is particularly useful if most of the members should be constant but a few need to be updatable.<br>But we cannot use the mutable specifier with names declared as static or const</p>
<p>seems that we can use the keyword <strong>‘mutable’</strong> in lambda.<br>I will add this in the future(Maybe ‘learning from scratch 2023 10 02’)</p>
<h2 id="19-parameter-list-in-C"><a href="#19-parameter-list-in-C" class="headerlink" title="19.parameter list in C++"></a>19.parameter list in C++</h2><p>we can initialise member variables of our instance by using parameter list when calling constructors.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(std::string name, <span class="type">int</span> score):<span class="built_in">m_Name</span>(name), <span class="built_in">m_Score</span>(score)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>so <strong>Why we use parameter list to initialise our member variable</strong><br>maybe clean and readable?<br>seems that we can avoid recreating objects of class?</p>
<p>see something enlightening below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Example</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Created Entity with &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Score;</span><br><span class="line">	Example m_EXample;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() &#123;</span><br><span class="line">		m_Name = std::<span class="built_in">string</span>(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">		m_EXample = <span class="built_in">Example</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/../img/Create_two_entities.png" alt="we have created two entities"><br>so actually we run the following code when we create the instance ‘e’.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example m_Example;  <span class="comment">//call the non-parameter constructor</span></span><br><span class="line">m_Example = <span class="built_in">Example</span>(<span class="number">8</span>); <span class="comment">//call the Example(int x)&#123;...&#125; constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>what if we use parameter list to instantiate our object?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() : <span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>)) &#123;</span><br><span class="line">		m_Name = std::<span class="built_in">string</span>(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/../img/use_parameterlist_to_avoid_recreation.png" alt="our output only has one line now!"><br>we succeed!</p>
<h2 id="20-Ternary-Operator-in-C"><a href="#20-Ternary-Operator-in-C" class="headerlink" title="20. Ternary Operator in C++"></a>20. Ternary Operator in C++</h2><p>something like below, quite easy to understand!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    s_Speed = s_Level &gt; <span class="number">5</span> ? <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//or something more complex</span></span><br><span class="line">    s_Speed = s_Level &gt; <span class="number">5</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//looks like a bit confusing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="21-Create-Instantiate-Objects-in-C"><a href="#21-Create-Instantiate-Objects-in-C" class="headerlink" title="21. Create&#x2F;Instantiate Objects in C++"></a>21. Create&#x2F;Instantiate Objects in C++</h2><p>let’s dive into something about scope, visibility, and ‘stack vs. heap’<br>see something enlighting below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x):<span class="built_in">m_Name</span>(<span class="string">&quot;Create in Heap&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Create an Entity with &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity* e;</span><br><span class="line">    <span class="comment">//within the scope</span></span><br><span class="line">    &#123;   <span class="comment">//will create an instance in stack        </span></span><br><span class="line">        <span class="comment">//Entity e1(4); </span></span><br><span class="line">        <span class="comment">//will kill after the scope end.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if we use the keyword &#x27;new&#x27;</span></span><br><span class="line">        Entity *e1 = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">4</span>); <span class="comment">//will create an instance in heap</span></span><br><span class="line">        e = e1;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/../img/keword_new_in_instantiation.png" alt="keyword &#39;new&#39; w.r.t instantiation"></p>
<p>the first line of output indicates that we call the constructor within the scope when we instantiate an object called e1.<br>the second line of output indicates that we can still find e1 even though the scope end, which means that by using keyword <strong>‘new’</strong>, we create an object in heap.</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/21/CPPtutorial/" data-id="clp635lp60001bgfw0ov0b4lc" data-title="My notebook for CPP Tutorial" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-Programming/" rel="tag">-c++ -Programming</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/15/Use-Kruskal-Prim-to-solve-Min-cost-to-connect-all-points-problem/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Use Kruskal &amp; Prim to solve &#39;Min cost to connect all points&#39; problem
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-2023tutorial/">-Programming -2023tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-Programming/" rel="tag">-c++ -Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deep-learning/" rel="tag">-deep learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Leetcode-Graph-Problems/" rel="tag">Algorithm, Leetcode, Graph Problems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COMPSCI4084/" rel="tag">COMPSCI4084</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Introduction-to-data-science-and-system/" rel="tag">Introduction to data science and system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learning-from-scratch/" rel="tag">learning from scratch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/" rel="tag">machine learning</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c-Programming/" style="font-size: 20px;">-c++ -Programming</a> <a href="/tags/deep-learning/" style="font-size: 10px;">-deep learning</a> <a href="/tags/Algorithm-Leetcode-Graph-Problems/" style="font-size: 20px;">Algorithm, Leetcode, Graph Problems</a> <a href="/tags/COMPSCI4084/" style="font-size: 10px;">COMPSCI4084</a> <a href="/tags/Introduction-to-data-science-and-system/" style="font-size: 10px;">Introduction to data science and system</a> <a href="/tags/Machine-Learning/" style="font-size: 10px;">Machine Learning</a> <a href="/tags/learning-from-scratch/" style="font-size: 10px;">learning from scratch</a> <a href="/tags/machine-learning/" style="font-size: 20px;">machine learning</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/29/numpy-learning-from-scratch/">numpy learning from scratch</a>
          </li>
        
          <li>
            <a href="/2022/09/15/Use-Kruskal-Prim-to-solve-Min-cost-to-connect-all-points-problem/">Use Kruskal &amp; Prim to solve &#39;Min cost to connect all points&#39; problem</a>
          </li>
        
          <li>
            <a href="/2022/02/21/CPPtutorial/">My notebook for CPP Tutorial</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Joseph Wang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>